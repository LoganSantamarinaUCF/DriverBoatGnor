#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

// MPU6050 setup
MPU6050 mpu;
float currentAngle = 0; // Track heading

// Define ESC and rudder servo
Servo esc;
Servo rudder;
const int escPin = 9;
const int rudderPin = 10;

// Button Pin (connected to pin 7)
const int buttonPin = 7;
bool buttonPressed = false;
unsigned long buttonPressTime = 0;
const unsigned long delayTime = 5000; // 5-second delay

// Boat State
enum BoatState {IDLE, MOVING};
BoatState currentState = IDLE;

// Boat movement states
enum MovementState {LEG1, LEG2, LEG3, LEG4, LEG5};
MovementState movementState = LEG1;

// Boat kinematic values
const float speed = 1.0; // Speed in feet per second (adjustable as you measure)
const float leg1Distance = 40.0; // Distance for leg1 in feet
const float leg2Distance = 40.0 * sqrt(2); // Distance for leg2 (diagonal)
const float leg3Distance = 40.0;
const float leg4Distance = 40.0 * sqrt(2); // Distance for leg4 (diagonal)
const float leg5Distance = 40.0;

// Setup function
void setup() {
    Serial.begin(115200);
    Wire.begin();
    mpu.initialize();

    esc.attach(escPin);
    rudder.attach(rudderPin);

    // Initialize ESC (Assumes 1000-2000us PWM range)
    esc.writeMicroseconds(1000); // Stop motor
    delay(2000); // Allow ESC to initialize

    // Ensure MPU6050 is connected
    if (!mpu.testConnection()) {
        Serial.println("MPU6050 connection failed!");
        while (1);
    }
    Serial.println("MPU6050 connected.");

    // Initialize the button pin
    pinMode(buttonPin, INPUT_PULLUP); // Use internal pull-up resistor
}

void loop() {
    // Check button state (button pressed when LOW)
    if (digitalRead(buttonPin) == LOW && !buttonPressed) {
        // Button pressed, record the press time
        buttonPressed = true;
        buttonPressTime = millis();
        Serial.println("Button pressed, starting 5 second delay...");
    }

    // Wait for 5 seconds after button press
    if (buttonPressed && (millis() - buttonPressTime >= delayTime)) {
        // 5 seconds have passed, start moving
        currentState = MOVING;
        buttonPressed = false; // Reset the button press state
        Serial.println("5 seconds passed, starting the boat...");
    }

    // Act based on the boat's current state
    if (currentState == MOVING) {
        switch (movementState) {
            case LEG1:
                moveLeg(leg1Distance);
                break;
            case LEG2:
                moveLeg(leg2Distance);
                break;
            case LEG3:
                moveLeg(leg3Distance);
                break;
            case LEG4:
                moveLeg(leg4Distance);
                break;
            case LEG5:
                moveLeg(leg5Distance);
                break;
        }
    }
}

// Motor control functions
void driveForward() {
    esc.writeMicroseconds(1500); // Adjust throttle for forward motion
}

void driveForwardSlow() {
    esc.writeMicroseconds(1200); // Adjust throttle for turning motion
}

void stopMotor() {
    esc.writeMicroseconds(1000); // Stop motor
}

void turnLeft() {
    // Get the initial angle from the gyro
    float initialAngle = getGyroAngle();
    float targetAngle = initialAngle + 45; // Target 45 degrees turn
    
    // Turn rudder left to start turning
    rudder.write(90 - 45); // Adjust rudder for left turn
    delay(100); // Small delay to ensure rudder starts moving

    // Keep motor running while turning
    driveForwardSlow();

    // Now wait until the boat has turned 45 degrees using the gyroscope
    while (getGyroAngle() < targetAngle) {
        delay(50); // Small delay for stability
    }

    stopMotor(); // Stop motor after the turn is completed
    rudder.write(90); // Reset rudder to neutral position
    Serial.println("Turn completed.");
}

// Read gyro angle to track boat's heading
float getGyroAngle() {
    int16_t ax, ay, az, gx, gy, gz;
    mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
    float angle = (gx / 131.0) * 0.01; // Convert gyro reading to degrees
    currentAngle += angle;
    return currentAngle;
}

// Move boat for a specified distance (in feet)
void moveLeg(float distance) {
    float timeToMove = distance / speed; // Calculate the time required to move the given distance (time = distance / speed)
    Serial.print("Moving for "); 
    Serial.print(timeToMove); 
    Serial.println(" seconds.");

    // Move forward for the required time
    driveForward();
    delay(timeToMove * 1000); // Convert time to milliseconds for delay
    stopMotor();

    // Turn left 45 degrees using the gyroscope
    turnLeft();

    // Update state to the next leg
    if (movementState == LEG1) {
        movementState = LEG2;
    } else if (movementState == LEG2) {
        movementState = LEG3;
    } else if (movementState == LEG3) {
        movementState = LEG4;
    } else if (movementState == LEG4) {
        movementState = LEG5;
    } else {
        movementState = LEG1; // Reset to first leg if needed
        currentState = IDLE;  // Optionally, reset to IDLE after completing all legs
        Serial.println("Boat has completed the path!");
    }
}
